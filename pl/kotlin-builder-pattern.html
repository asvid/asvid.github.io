<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="refresh" content="0;url=https://swiderski.tech/" />
    <title>Redirecting...</title>
    <script>
      var currentUrl = window.location.href
      var path = currentUrl.split('asvid.github.io')[1]
      window.location.href = 'https://swiderski.tech' + path
    </script>
  </head>
  <body>
    <div class="post-header" style="
	
	background:	url(/assets/posts/kotlin-builder-pattern/pkin.jpg);
    background-size: cover;
    background-position: center;
	">
    <h1>Kotlin Builder Pattern </h1>
</div>

<article>

    <div class="col-sm-10">
	 <span class="post-date">

	   
	   January
	   20th,
	   
	   2021

         <!--    <span class="read_time">(czas czytania:-->
         <!--      -->
         <!--      -->
         <!--        16 min)-->
         <!--      -->
         <!--      </span>-->
	 </span>

        <span class="reading-time" title="Estimated read time">

   </span>

        <div class="article_body">

            <nav aria-label="Table of Contents">
                <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#przeznaczenie">Przeznaczenie</a></li>
<li class="toc-entry toc-h2"><a href="#elementy">Elementy</a></li>
<li class="toc-entry toc-h2"><a href="#implementacja">Implementacja</a></li>
<li class="toc-entry toc-h2"><a href="#alternatywa">Alternatywa</a></li>
<li class="toc-entry toc-h2"><a href="#podsumowanie">Podsumowanie</a></li>
</ul>
            </nav>

            <h2 id="przeznaczenie">Przeznaczenie</h2>
<p>Wzorzec Builder służy do uproszczenia tworzenia złożonych obiektów ze skomplikowaną logiką budowania lub z wieloma 
argumentami w konstruktorze. Dzięki zastosowaniu tego wzorca obiekt łatwo może być niemutowalny, bo dostajemy taki 
obiekt, jaki ustawiliśmy przez Buildera, więc nie ma potrzeby na nim już wołać żadnych setterów :)</p>

<p>Builder niejako zdejmuje z użytkownika konieczność zrozumienia wewnętrznej implementacji sposobu tworzenia obiektu i 
gwarantuje jego poprawne utworzenie lub zwrócenie błędu.</p>

<p>Zaletą korzystania z Buildera jest możliwość użycia zmiennej liczby argumentów (<code class="language-plaintext highlighter-rouge">vararg</code>) w wielu miejscach, bo każda 
metoda Buildera może przyjmować taki argument, a w konstruktorze klasy może być tylko 1 argument tego typu.</p>

<p>Builder rozwiązuje problem tzw. konstruktorów teleskopowych, czyli wariantów konstruktora z rosnącą liczbą argumentów.</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constructor</span><span class="p">(</span><span class="n">firstName</span><span class="p">:</span> <span class="nc">String</span><span class="p">):</span> <span class="k">this</span><span class="p">(</span><span class="n">firstName</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">constructor</span><span class="p">(</span><span class="n">firstName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">lastName</span><span class="p">:</span> <span class="nc">String</span><span class="p">):</span> <span class="k">this</span><span class="p">(</span><span class="n">firstName</span><span class="p">,</span> <span class="n">lastName</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">constructor</span><span class="p">(</span><span class="n">firstName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">lastName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="k">this</span><span class="p">(</span><span class="n">firstName</span><span class="p">,</span> <span class="n">lastName</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
</code></pre></div></div>
<p>W teorii pozwalają one użyć konstruktora z taką ilością argumentów jaką potrzebujemy, ale w praktyce dodanie nowego 
pola do klasy powoduje konieczność edycji wszystkich konstruktorów. Na szczęście w Kotlinie mamy nazwane argumenty i 
nie trzeba naśladować Javy.</p>

<p>Z mojego doświadczenia wynika, że tego wzorca znacznie częściej się używa, niż pisze samemu, ale i tak warto go znać 
i stosować.</p>

<h3 id="przykładowe-użycie">Przykładowe użycie</h3>
<p>Z racji mojego zawodowego skrzywienia przykłady pochodzą ze świata Androida.</p>

<h4 id="notificationbuilder">NotificationBuilder</h4>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">notificationBuilder</span> <span class="p">=</span> <span class="nc">Notification</span><span class="p">.</span><span class="nc">Builder</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"channelId"</span><span class="p">)</span>
<span class="n">notificationBuilder</span><span class="p">.</span><span class="nf">setContentTitle</span><span class="p">(</span><span class="s">"Title"</span><span class="p">)</span>
<span class="n">notificationBuilder</span><span class="p">.</span><span class="nf">setContentText</span><span class="p">(</span><span class="s">"Content"</span><span class="p">)</span>
<span class="n">notificationBuilder</span><span class="p">.</span><span class="nf">setSmallIcon</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">mipmap</span><span class="p">.</span><span class="n">ic_launcher</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">notification</span> <span class="p">=</span> <span class="n">notificationBuilder</span><span class="p">.</span><span class="nf">build</span><span class="p">()</span>
</code></pre></div></div>
<p>Chyba najbardziej tradycyjne użycie wzorca. Konstruktor Buildera przyjmuje 2 argumenty niezbędne do poprawnego 
utworzenia obiektu powiadomienia, reszta pól jest ustawiana przez settery wywołane na instancji Buildera. Na koniec 
wywoływana jest metoda <code class="language-plaintext highlighter-rouge">build()</code> która zwraca obiekt powiadomienia.</p>

<h4 id="dexter">Dexter</h4>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DialogOnAnyDeniedMultiplePermissionsListener</span><span class="p">.</span><span class="nc">Builder</span>
		<span class="p">.</span><span class="nf">withContext</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
		<span class="p">.</span><span class="nf">withTitle</span><span class="p">(</span><span class="s">"Camera permission"</span><span class="p">)</span>
		<span class="p">.</span><span class="nf">withMessage</span><span class="p">(</span><span class="s">"Camera permission is needed to take pictures of your cat"</span><span class="p">)</span>
		<span class="p">.</span><span class="nf">withButtonText</span><span class="p">(</span><span class="n">android</span><span class="p">.</span><span class="nc">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">ok</span><span class="p">)</span>
		<span class="p">.</span><span class="nf">withIcon</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">mipmap</span><span class="p">.</span><span class="n">my_icon</span><span class="p">)</span>
		<span class="p">.</span><span class="nf">build</span><span class="p">()</span>
</code></pre></div></div>
<p>W tym przykładzie metody Buildera są połączone w łańcuch, dlatego że każda z nich zwraca instancję Buildera, czyli 
<code class="language-plaintext highlighter-rouge">this</code>. Przy odpowiednim nazywaniu metod czyta się takie wywołanie prawie jak zdanie. Oczywiście w trakcie pisania kodu IDE potrafi wyświetlić nazwę parametru w metodzie i pomaga to zachować właściwą kolejność, ale w trakcie code review, kiedy jesteśmy zdani na sam tekst, to ubranie tworzenia obiektu w ładnie nazwane metody zdecydowanie pomaga zorientować się co się dzieje bez konieczności zaglądania głębiej w kod.</p>

<h4 id="alertdialog">AlertDialog</h4>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">dialog</span> <span class="p">=</span> <span class="nc">AlertDialog</span><span class="p">.</span><span class="nc">Builder</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">apply</span> <span class="p">{</span>
        <span class="nf">setTitle</span><span class="p">(</span><span class="s">"Title"</span><span class="p">)</span>
        <span class="nf">setIcon</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">mipmap</span><span class="p">.</span><span class="n">ic_launcher</span><span class="p">)</span>
    <span class="p">}.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>
<p>Bardzo Kotlinowe podejście z użyciem <code class="language-plaintext highlighter-rouge">apply</code>. Co ciekawe, nie ma metody <code class="language-plaintext highlighter-rouge">build()</code> tylko <code class="language-plaintext highlighter-rouge">show()</code> która nie tylko 
zwraca obiekt, ale też wyświetla dialog na ekranie. Teoretycznie metoda powinna robić tylko jedną rzecz, ale tutaj 
jej odpowiedzialność została rozszerzona. Prawdopodobnie z powodu częstego błędu utworzenia dialogu i 
późniejszego braku wywołania metody wyświetlenia go.</p>

<h2 id="elementy">Elementy</h2>
<p>Builder to w najczęściej jedna wewnętrzna klasa pomocnicza. Podejściem “bandy czworga” z wykorzystaniem <code class="language-plaintext highlighter-rouge">Director</code> i <code class="language-plaintext highlighter-rouge">ConcreteBuilder</code> nie będę się tutaj zajmował, nigdy go nie widziałem w kodzie produkcyjnym :)</p>

<h3 id="konstruktor">Konstruktor</h3>
<p>Wbrew pozorom bardzo ważny jest w niej konstruktor, mimo że często nie 
przyjmuje żadnych argumentów. Powinny się w nim znaleźć wszystkie parametry, bez których nie da się utworzyć 
poprawnego obiektu tworzonego przez Builder.</p>
<blockquote>
  <p>Wydaje się to oczywiste, ale na Androidzie swego czasu można było utworzyć poprawne powiadomienie, które nie 
miało szans zostać wyświetlone przez system. 
Wystarczyło zapomnieć ustawić tytuł, treść lub ikonę powiadomienia — żadnej z tych rzeczy nie wymagał konstruktor 
Buildera. 
System nie rzucał żadnym wyjątkiem przy próbie wyświetlenia niepoprawnie utworzonego powiadomienia…</p>
</blockquote>

<h3 id="metody">Metody</h3>
<p>Poza konstruktorem Builder dostarcza metody, którymi możemy ustawić budowany obiekt.
W przypadku braku ustawienia jakiejś właściwości obiektu zastosowana będzie wartość domyślna. Może nią być <code class="language-plaintext highlighter-rouge">null</code>. 
Dzięki świetnej obsłudze nullability w Kotlinie znacznie lepiej jest wykorzystać domyślny <code class="language-plaintext highlighter-rouge">null</code> niż np. pusty 
<code class="language-plaintext highlighter-rouge">String</code> czy magiczną wartość, jak <code class="language-plaintext highlighter-rouge">-1</code> w miejscu, gdzie spodziewamy się wartości dodatniej. Żeby sprawdzić, czy pole 
zostało w ogóle ustawione wystarczy potem sprawdzić <code class="language-plaintext highlighter-rouge">!= null</code> lub lepiej z użyciem <code class="language-plaintext highlighter-rouge">?</code>, zamiast porównywać do jakiejś 
domyślnej wartości nieustawienia konkretnego typu w danym projekcie/klasie.</p>

<p>Metody powinny być możliwe do wywołania w dowolnej kolejności.</p>

<p>No i obowiązkowa metoda <code class="language-plaintext highlighter-rouge">build()</code> (lub inna sensownie nazwana dla domeny, patrz <code class="language-plaintext highlighter-rouge">show()</code> dla dialogu) zwracająca 
budowany obiekt.</p>

<p>Jeśli już decydujemy się na użycie tego wzorca, to dobrze ograniczyć możliwość użycia konstruktora wynikowego obiektu tylko przez Builder.</p>

<h3 id="weryfikacja-argumentów">Weryfikacja argumentów</h3>
<p>Jeśli podamy w Builderze niepoprawne dane to kiedy i jak powinniśmy zostać o tym poinformowani?
Podejść jest co najmniej kilka, np.:</p>
<ol>
  <li>Jak najszybciej, czyli metoda Buildera przyjmująca argument powinna go weryfikować, ale:
    <ul>
      <li>co jeśli poprawna wartość jednego argumentu zależy od innego? Jeśli kolejność wywoływania setterów Buildera ma znaczenie to co nam daje ten wzorzec ponad tradycyjne tworzenie obiektu?</li>
      <li>walidacja w samych setterach może nie być wystarczająca, więc i tak trzeba sprawdzić wartości w metodzie <code class="language-plaintext highlighter-rouge">build()</code></li>
    </ul>
  </li>
  <li>Metoda <code class="language-plaintext highlighter-rouge">build()</code> powinna sprawdzić wszystkie argumenty, bo mogą być między nimi zależności i dlatego w ogóle 
został użyty ten wzorzec, więc:
    <ul>
      <li>poprawnie stworzony Builder pozwala na wywołanie metod w łańcuchu, więc walidacja w metodzie <code class="language-plaintext highlighter-rouge">build()</code> wcale nie jest wywoływana jakoś szczególnie później od setterów</li>
      <li>jesteśmy w stanie zweryfikować zależności między argumentami jeśli istnieją</li>
      <li>ale jeśli dany Builder nie jest jedyną możliwością tworzenia obiektu, to walidacje trzeba skopiować w każde 
miejsce, które tworzy dany obiekt</li>
    </ul>
  </li>
  <li>To nie Builder powinien weryfikować poprawność, tylko sam tworzony obiekt
    <ul>
      <li>mamy tutaj zachowane SRP (Single-Responsibility Principle), bo Builder buduje obiekt, a obiekt sam potrafi 
zwalidować swoje pola</li>
      <li>nie mamy potrzeby kopiowania walidacji, każdy sposób tworzenia obiektu będzie przechodził przez tą w obiekcie</li>
    </ul>
  </li>
</ol>

<p><a href="https://softwareengineering.stackexchange.com/questions/241309/builder-pattern-when-to-fail">Ciekawy wątek w temacie na StackExchange</a> , 
gdzie niektórzy sugerują połączenie podejść 2 i 3.
Chodzi o to, żeby Builder veryfikował własne kontrakty, a obiekt swoje. Podany tam jest fajny przykład Buildera, 
który zwraca <code class="language-plaintext highlighter-rouge">String</code> zawierający kolejne przedziały liczbowe, np “1-2,3-4,5-6”. Klasa <code class="language-plaintext highlighter-rouge">String</code> sama w sobie nie ma jak 
zweryfikować poprawności dodanych przedziałów — to nie jest jej odpowiedzialność, ona tylko przechowuje ciąg znaków.
Za to Builder jest w stanie i powinien w tym przypadku sprawdzić, czy przedziały mają sens i np. nie nachodzą na 
siebie (jeśli jest taka potrzeba). Wtedy metoda np. <code class="language-plaintext highlighter-rouge">addRange(min Int,max Int)</code> powinna rzucić wyjątek 
<code class="language-plaintext highlighter-rouge">IllegalArgumentException</code> kiedy <code class="language-plaintext highlighter-rouge">min</code> jest większe od <code class="language-plaintext highlighter-rouge">max</code> a metoda <code class="language-plaintext highlighter-rouge">build()</code> kiedy dodane zostaną przedziały jak 
<code class="language-plaintext highlighter-rouge">1-4</code> i <code class="language-plaintext highlighter-rouge">2-6</code>. Chociaż tutaj też pewnie można dyskutować, czy już <code class="language-plaintext highlighter-rouge">addRange()</code> nie powinno tego sprawdzać.</p>

<p>W każdym razie trzymałbym się zasady, że to obiekt sprawdza swoje kontrakty, a Builder swoje.
<a href="https://pl.wikipedia.org/wiki/Joshua_Bloch">Joshua Bloch</a> w książce “Java - efektywne programowanie” 
(rozdział 2, temat 2) również sugeruje weryfikację poprawności wartości argumentów dopiero w tworzonym obiekcie, a 
nie w samym Builderze.</p>

<h2 id="implementacja">Implementacja</h2>

<h3 id="w-stylu-javy">W stylu Javy</h3>
<p>Goły przykład najprostszego możliwego Buildera. W zasadzie Java przekonwertowana na Kotlin, bez użycia żadnych fajerwerków.
Mamy tutaj:</p>
<ul>
  <li>prywatny konstruktor w <code class="language-plaintext highlighter-rouge">Product</code> żeby tylko wewnętrzny Builder mógł utworzyć obiekt</li>
  <li>wymagane pole <code class="language-plaintext highlighter-rouge">requiredProperty</code> w konstruktorze Buildera</li>
  <li>opcjonalne pole ustawiane przez metodę <code class="language-plaintext highlighter-rouge">optionalProperty()</code>, domyślnie <code class="language-plaintext highlighter-rouge">null</code> co jest akceptowane przez 
obiekt <code class="language-plaintext highlighter-rouge">Product</code></li>
  <li>metodę <code class="language-plaintext highlighter-rouge">optionalProperty()</code> zwraca instancję Buildera po to, żeby można było łączyć metody w łańcuch</li>
  <li>metodę <code class="language-plaintext highlighter-rouge">build()</code> tworzącą <code class="language-plaintext highlighter-rouge">Product</code> z ustawionymi w Builderze argumentami</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Product</span> <span class="k">private</span> <span class="k">constructor</span><span class="p">(</span>
    <span class="kd">val</span> <span class="py">property</span><span class="p">:</span> <span class="nc">Any</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">optionalProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?</span>
<span class="p">)</span> <span class="p">{</span>

    <span class="kd">class</span> <span class="nc">Builder</span><span class="p">(</span><span class="k">private</span> <span class="kd">val</span> <span class="py">requiredProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">private</span> <span class="kd">var</span> <span class="py">optionalProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

        <span class="k">fun</span> <span class="nf">optionalProperty</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?):</span> <span class="nc">Builder</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">optionalProperty</span> <span class="p">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="k">this</span>
        <span class="p">}</span>

        <span class="k">fun</span> <span class="nf">build</span><span class="p">():</span> <span class="nc">Product</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nc">Product</span><span class="p">(</span><span class="n">requiredProperty</span><span class="p">,</span> <span class="n">optionalProperty</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>I wywołanie</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">product</span> <span class="p">=</span> <span class="nc">Product</span><span class="p">.</span><span class="nc">Builder</span><span class="p">(</span><span class="s">"required"</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">optionalProperty</span><span class="p">(</span><span class="s">"optional"</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">build</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="bardziej-kotlin">Bardziej Kotlin</h3>
<p>Builder w konstruktorze określa wszystkie pola i ich ewentualne domyślne wartości.
Mógłby to być <code class="language-plaintext highlighter-rouge">data class</code> ale w tym przypadku nie daje to żadnych korzyści. 
Brak domyślnej wartości w konstruktorze Buildera powoduje, że argument <code class="language-plaintext highlighter-rouge">requiredProperty</code> staje się wymagany.</p>

<p>Użycie <code class="language-plaintext highlighter-rouge">apply</code> sprawia, że z <code class="language-plaintext highlighter-rouge">optionalProperty()</code> jest zwracana instancja Buildera. 
Jest tu też użyty tzw <a href="https://kotlinlang.org/docs/reference/functions.html#single-expression-functions">single-expression function</a>,
czyli brak jawnej deklaracji zwracanego przez metodę typu.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FancyProduct</span> <span class="k">private</span> <span class="k">constructor</span><span class="p">(</span>
    <span class="kd">val</span> <span class="py">property</span><span class="p">:</span> <span class="nc">Any</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">optionalProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?</span>
<span class="p">)</span> <span class="p">{</span>

    <span class="kd">class</span> <span class="nc">Builder</span><span class="p">(</span>
        <span class="k">private</span> <span class="kd">var</span> <span class="py">requiredProperty</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
        <span class="k">private</span> <span class="kd">var</span> <span class="py">optionalProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>

        <span class="k">fun</span> <span class="nf">optionalProperty</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nc">Any</span><span class="p">)</span> <span class="p">=</span> <span class="nf">apply</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="n">optionalProperty</span> <span class="p">=</span> <span class="n">value</span> <span class="p">}</span>

        <span class="k">fun</span> <span class="nf">build</span><span class="p">():</span> <span class="nc">FancyProduct</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nc">FancyProduct</span><span class="p">(</span><span class="n">requiredProperty</span><span class="p">,</span> <span class="n">optionalProperty</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Takiego Buildera możemy użyć na kilka sposobów:</p>
<ul>
  <li>identycznie jak w Javie lub w pierwszym przykładzie w Kotlinie wzorowanym na Javie</li>
  <li>podając oba argumenty (wymagany i opcjonalny) od razu w konstruktorze Buildera</li>
  <li>również podając oba, ale w dowolnej kolejności korzystając z nazwanych argumentów</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">fancyProduct</span> <span class="p">=</span> <span class="nc">FancyProduct</span><span class="p">.</span><span class="nc">Builder</span><span class="p">(</span><span class="s">"required"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">optionalProperty</span><span class="p">(</span><span class="s">"optional"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">build</span><span class="p">()</span>

<span class="kd">val</span> <span class="py">fancyProduct2</span> <span class="p">=</span> <span class="nc">FancyProduct</span><span class="p">.</span><span class="nc">Builder</span><span class="p">(</span>
    <span class="s">"required"</span><span class="p">,</span>
    <span class="s">"optional"</span>
<span class="p">).</span><span class="nf">build</span><span class="p">()</span>

<span class="kd">val</span> <span class="py">fancyProduct3</span> <span class="p">=</span> <span class="nc">FancyProduct</span><span class="p">.</span><span class="nc">Builder</span><span class="p">(</span>
    <span class="n">optionalProperty</span> <span class="p">=</span> <span class="s">"optional"</span><span class="p">,</span>
    <span class="n">requiredProperty</span> <span class="p">=</span> <span class="s">"required"</span>
<span class="p">).</span><span class="nf">build</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="kotlin-dsl">Kotlin DSL</h3>
<p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL (Domain Specific Language)</a> czyli język programowania utworzony pod konkretną domenę.
Kotlin pozwala na dość proste i przyjemne tworzenie funkcji, które potem umożliwiają w czysto domenowy sposób opisać nasz obiekt.</p>

<p>Builder wygląda tak samo, jak w poprzednim przykładzie.</p>

<p>W klasie <code class="language-plaintext highlighter-rouge">DslProduct</code> doszedł <code class="language-plaintext highlighter-rouge">companion object</code> który posiada metodę <code class="language-plaintext highlighter-rouge">dslProduct()</code> za pomocą której będziemy tworzyć nasz obiekt.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">DslProduct</span> <span class="k">private</span> <span class="k">constructor</span><span class="p">(</span>
        <span class="kd">val</span> <span class="py">requiredProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">,</span>
        <span class="kd">val</span> <span class="py">optionalProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
        <span class="k">inline</span> <span class="k">fun</span> <span class="nf">dslProduct</span><span class="p">(</span><span class="n">requiredProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="nc">Builder</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="nc">Unit</span><span class="p">)</span> <span class="p">=</span>
                <span class="nc">Builder</span><span class="p">(</span><span class="n">requiredProperty</span><span class="p">)</span>
                        <span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                        <span class="p">.</span><span class="nf">build</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">class</span> <span class="nc">Builder</span><span class="p">(</span>
            <span class="k">private</span> <span class="kd">val</span> <span class="py">requiredProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">,</span>
            <span class="k">private</span> <span class="kd">var</span> <span class="py">optionalProperty</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">fun</span> <span class="nf">optionalProperty</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?)</span> <span class="p">=</span> <span class="nf">apply</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="n">optionalProperty</span> <span class="p">=</span> <span class="n">value</span> <span class="p">}</span>
        <span class="k">fun</span> <span class="nf">build</span><span class="p">()</span> <span class="p">=</span> <span class="nc">DslProduct</span><span class="p">(</span><span class="n">requiredProperty</span><span class="p">,</span> <span class="n">optionalProperty</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Wywołanie takiego prostego DSLa wygląda tak:</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">dslProduct</span> <span class="p">=</span> <span class="nf">dslProduct</span><span class="p">(</span><span class="s">"required"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">optionalProperty</span><span class="p">(</span><span class="s">"optional"</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Dla tak prostego obiektu nie wygląda to szczególnie zachęcająco, ale jeśli nasz Builder jest kompozycją innych 
Builderów, to zaczyna robić się ciekawie.
Przykład poniżej pochodzi z mojej aplikacji, który zrealizowałem przy pomocy <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">DslMaker</a>. 
To część standardowej biblioteki Kotlina i dodatkowo zadba o zasięgi wewnętrznych Builderów.
Adres, położenie i godziny otwarcia również wykorzystują Buildery i DSL do stworzenia swoich obiektów.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">shop</span> <span class="p">=</span> <span class="nf">shop</span><span class="p">(</span><span class="s">"ID"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">address</span> <span class="p">=</span> <span class="nf">address</span> <span class="p">{</span>
        <span class="n">cityName</span> <span class="p">=</span> <span class="s">"Poznań"</span>
        <span class="n">streetName</span> <span class="p">=</span> <span class="s">"ul. Półwiejska"</span>
        <span class="n">streetNumber</span> <span class="p">=</span> <span class="s">"123/2"</span>
    <span class="p">}</span>
    <span class="n">location</span> <span class="p">=</span> <span class="nf">location</span> <span class="p">{</span>
        <span class="n">lat</span> <span class="p">=</span> <span class="mf">53.12</span>
        <span class="n">lng</span> <span class="p">=</span> <span class="mf">23.4</span>
    <span class="p">}</span>
    <span class="n">openHours</span> <span class="p">=</span> <span class="nf">openHours</span> <span class="p">{</span>
        <span class="n">weekDay</span> <span class="p">=</span> <span class="s">"6:00-22:00"</span>
        <span class="n">saturday</span> <span class="p">=</span> <span class="s">"7:00-23:00"</span>
        <span class="n">sunday</span> <span class="p">=</span> <span class="s">"closed"</span>
    <span class="p">}</span>
    <span class="nf">features</span><span class="p">(</span>
            <span class="nc">Feature</span><span class="p">.</span><span class="nc">Bakery</span><span class="p">,</span>
            <span class="nc">Feature</span><span class="p">.</span><span class="nc">Atm</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Pełny przykład z użyciem DslMaker jest -&gt; <a href="https://gist.github.com/asvid/5fed8dd3c831c2a72744e8ffe8f7dc0f">tutaj</a> &lt;- Ale to nadal dość prosty przykład i sam DSL zasługuje na osobny wpis.</p>

<p>Podejście DSL wymaga jednak napisania pewnego kodu boilerplate, który na pierwszy rzut oka nie wygląda zbyt przyjaźnie.</p>

<h2 id="alternatywa">Alternatywa</h2>
<p>Nazwane parametry w konstruktorze i domyślne wartości parametrów w tworzonym obiekcie mogą w pewnym sensie dawać podobny efekt co zastosowanie Buildera.
Sprawdzi się to raczej do mniej rozbudowanych obiektów. Warto też zadbać, żeby domyślne wartości tworzyły sensowną instancję obiektu z punktu widzenia domeny, 
a nie tylko “żeby się kompilowało”.</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">person</span> <span class="p">=</span> <span class="nc">Person</span><span class="p">(</span>
        <span class="n">firstName</span> <span class="p">=</span> <span class="s">"Adam"</span><span class="p">,</span>
        <span class="n">lastName</span> <span class="p">=</span> <span class="s">"Świderski"</span><span class="p">,</span>
        <span class="n">address</span> <span class="p">=</span> <span class="nc">Address</span><span class="p">(</span>
                <span class="n">cityName</span> <span class="p">=</span> <span class="s">"Poznań"</span><span class="p">,</span>
                <span class="n">streetName</span> <span class="p">=</span> <span class="s">"ul. Półwiejska"</span><span class="p">,</span>
                <span class="n">streetNumber</span> <span class="p">=</span> <span class="s">"123/1"</span><span class="p">,</span>
                <span class="n">country</span> <span class="p">=</span> <span class="s">"Poland"</span><span class="p">,</span>
                <span class="n">postalCode</span> <span class="p">=</span> <span class="s">"60-000"</span>
        <span class="p">),</span>
        <span class="n">contact</span> <span class="p">=</span> <span class="nc">Contact</span><span class="p">(</span>
                <span class="n">workEmail</span> <span class="p">=</span> <span class="s">"adam@work.email"</span><span class="p">,</span>
                <span class="n">workPhoneNumber</span> <span class="p">=</span> <span class="s">"+48 123112312"</span><span class="p">,</span>
                <span class="n">privateEmail</span> <span class="p">=</span> <span class="s">"adam@private.email"</span>
        <span class="p">),</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Wygląda nawet podobnie do DSL, ale bez konieczności używania adnotacji, pisania dodatkowych metod etc.
Warto zwrócić uwagę na pola takie jak <code class="language-plaintext highlighter-rouge">val height: Float? = null</code> - uznałem, że nie jest to niezbędna informacja do utworzenia instancji <code class="language-plaintext highlighter-rouge">Person</code>,
dlatego domyślna wartość tego pola to <code class="language-plaintext highlighter-rouge">null</code>. Tak <code class="language-plaintext highlighter-rouge">null</code> a nie np. <code class="language-plaintext highlighter-rouge">0.0</code> czy <code class="language-plaintext highlighter-rouge">-1</code>, albo jakaś magiczna stała <code class="language-plaintext highlighter-rouge">DEFAULT_HEIGHT</code>.</p>

<p>W blokach <code class="language-plaintext highlighter-rouge">init</code> są sprawdzane wartości podanych argumentów (patrz wyżej <code class="language-plaintext highlighter-rouge">Weryfikacja argumentów</code>). Wrzucenie złego 
typu argumentu zostanie wychwycone już na etapie kompilacji, ale obiekt może mieć jakieś domenowe wymagania, jak np. 
że wzrost jest zawsze dodatni, a rozmiar buta, o ile został podany, nie może być mniejszy niż 4.</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">Person</span><span class="p">(</span>
    <span class="kd">val</span> <span class="py">firstName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">lastName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">address</span><span class="p">:</span> <span class="nc">Address</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">contact</span><span class="p">:</span> <span class="nc">Contact</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">height</span><span class="p">:</span> <span class="nc">Float</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">shoeSize</span><span class="p">:</span> <span class="nc">Float</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="nf">init</span> <span class="p">{</span> 
        <span class="n">height</span><span class="o">?.</span><span class="nf">let</span> <span class="p">{</span> <span class="nf">require</span><span class="p">(</span><span class="mf">0f</span> <span class="p">&lt;</span> <span class="n">it</span><span class="p">)</span> <span class="p">{</span> <span class="s">"height is always greater than 0"</span> <span class="p">}</span> <span class="p">}</span>
        <span class="n">shoeSize</span><span class="o">?.</span><span class="nf">let</span> <span class="p">{</span> <span class="nf">require</span><span class="p">(</span><span class="mf">4f</span> <span class="p">&lt;=</span> <span class="n">it</span><span class="p">)</span> <span class="p">{</span> <span class="s">"smallest standard shoe size is 4"</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">data class</span> <span class="nc">Address</span><span class="p">(</span>
    <span class="kd">val</span> <span class="py">country</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">cityName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">streetName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">streetNumber</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">postalCode</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">district</span><span class="p">:</span> <span class="nc">String</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
<span class="p">)</span>

<span class="kd">data class</span> <span class="nc">Contact</span><span class="p">(</span>
    <span class="kd">val</span> <span class="py">workPhoneNumber</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">workEmail</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">privatePhoneNumber</span><span class="p">:</span> <span class="nc">String</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">privateEmail</span><span class="p">:</span> <span class="nc">String</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="nf">init</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">workPhoneNumber</span><span class="p">.</span><span class="nf">isValidPhoneNumber</span><span class="p">())</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">workEmail</span><span class="p">.</span><span class="nf">isValidEmail</span><span class="p">())</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">privatePhoneNumber</span><span class="o">?.</span><span class="nf">isValidPhoneNumber</span><span class="p">()</span> <span class="o">?:</span> <span class="k">true</span><span class="p">)</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">privateEmail</span><span class="o">?.</span><span class="nf">isValidEmail</span><span class="p">()</span> <span class="o">?:</span> <span class="k">true</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="podsumowanie">Podsumowanie</h2>
<p>Builder jest całkiem przydatnym wzorcem konstrukcyjnym i na pewno w trakcie pracy się z nim spotkasz. Potrafi znacząco uprościć tworzenie rozbudowanych obiektów. Dobrze nazwane metody Buildera połączone w łańcuch mogą sprawić, że tworzenie obiektu czyta się jak zdanie. Kotlin pozwala na znaczne uproszczenie boilerplate Buildera i wykorzystanie sposobów takich jak DSL i nazwane argumenty i wartości domyślne na osiągnięcie podobnego rezultatu bez pisania dodatkowego kodu.</p>

<p>W literaturze nt. wzorców projektowych można spotkać implementację Buildera z wykorzystaniem elementów takich jak: Director i ConcreteBuilder. Dopóki nie trzeba przekazywać jako argumenty do jakiegoś Buildera instancji innych Builderów aby w generyczny sposób tworzyć rozbudowane obiekty - powyższe przykłady i opis będą w zupełności wystarczające. A jeśli najdzie Cię potrzeba Builder-cepcji - może warto skorzystać z innego wzorca zamiast komplikować 
sobie życie :)</p>

        </div>
        <!--        -->
        <!--        <ul class="tag_box list-unstyled list-inline">-->
        <!--            <li><i class="fa fa-folder-open"></i></li>-->
        <!--            -->
        <!--            -->
        <!--            -->
        <!--            <li><a href="/pl/categories.html#pl-ref">-->
        <!--                pl <span>(19)</span>-->
        <!--                ,-->
        <!--            </a></li>-->
        <!--            -->
        <!--            <li><a href="/categories.html#Design Patterns-ref">-->
        <!--                Design Patterns <span>(11)</span>-->
        <!--                -->
        <!--            </a></li>-->
        <!--            -->
        <!--            -->
        <!--        </ul>-->
        <!--        -->

        
        <ul class="list-inline">
            <li><i class="fa fa-tags"></i></li>
            
            
            
            <li>
                <a href="/tags.html#design patterns-ref">
                    design patterns <span>(11)</span>
                    ,
                </a>
            </li>
            
            <li>
                <a href="/pl/tags.html#Kotlin-ref">
                    Kotlin <span>(11)</span>
                    ,
                </a>
            </li>
            
            <li>
                <a href="/tags.html#wzorce projektowe-ref">
                    wzorce projektowe <span>(1)</span>
                    ,
                </a>
            </li>
            
            <li>
                <a href="/tags.html#Builder Pattern-ref">
                    Builder Pattern <span>(1)</span>
                    ,
                </a>
            </li>
            
            <li>
                <a href="/tags.html#wzorce konstrukcyjne-ref">
                    wzorce konstrukcyjne <span>(1)</span>
                    
                </a>
            </li>
            
            
            
        </ul>
        

        <hr>

        <div>

            <section class="share col-sm-12">
                <h3 class="section-title">
                    Like the post? Disagree? Let me know
                    <a href="mailto:adam.swiderski89@gmail.com">
                        with email.
                    </a>
                </h3>
            </section>
            <section class="share col-sm-6">
                <h4 class="section-title">Share Post</h4>
                <a class="btn btn-default btn-sm twitter"
                   href="http://twitter.com/share?text=Kotlin Builder Pattern"
                   onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="fa fa-twitter fa-lg"></i>
                    Twitter
                </a>
                <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
                   onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="fa fa-facebook fa-lg"></i>
                    Facebook
                </a>
                <a class="btn btn-default btn-sm gplus"
                   onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="fa fa-google-plus fa-lg"></i>
                    Google+
                </a>
            </section>

            <section class="col-sm-6 author">
                <img src="/assets/profile_picture.png"
                     class="img-rounded author-image"
                     style="max-width: 64px; max-height: 64px;"
                />
                <h4 class="section-title author-name">Adam Świderski</h4>
                <p class="author-bio">software engineer</p>
            </section>
        </div>

        <div class="clearfix"></div>

        <ul class="pager">
            
            <li class="previous"><a href="/pl/code-review-retro"
                                    title="Code Review Retro">&larr; Previous</a></li>
            
            
            <li class="next"><a href="/pl/kotlin-static-factory-methods" title="Kotlin Static Factory Methods">Next
                &rarr;</a></li>
            
        </ul>

        <hr>
    </div>

    <div class="col-sm-2 sidebar-2">

    </div>
</article>
<div class="clearfix"></div>



  </body>
</html>



<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl =
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'G-313840737']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

