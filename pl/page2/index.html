<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="refresh" content="0;url=https://swiderski.tech/" />
    <title>Redirecting...</title>
    <script>
      var currentUrl = window.location.href
      var path = currentUrl.split('asvid.github.io')[1]
      window.location.href = 'https://swiderski.tech' + path
    </script>
  </head>
  <body>
    <div class="page-header">
  <h1>Adam's Coding Corner </h1>
</div>



<article class="home">

  <span class="post-date">
    
    July
    17th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin_mediator_pattern">Mediator w Kotlinie</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
     Zadaniem Mediatora jest organizować komunikację między bliskimi klasami. Wzorzec `Mediator` uwalnia zależności pomiędzy komponentami. Przejmuje na siebie interakcję między nimi, stając się głównym hubem komunikacyjnym dla grupy klas. Odwracamy sterowanie, ponieważ komponenty zaczynają informować tylko 'co się stało', zamiast nakazywać innym, żeby 'coś zrobiły'. Można go spotkać np. pod postacią `ViewModel` w Androidzie, gdzie oddziela interakcje UI od zmian modelu danych. 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      20 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#kotlin-ref">kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Mediator-Pattern-ref">Mediator Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    July
    3rd,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-decorator-pattern">Dekorator w Kotlinie</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
     `Dekorator` stosuje się tam, gdzie tworzenie osobnych klas będących kombinacją wszystkich możliwości skończyłoby się ich eksplozją. Wzorzec ten skupia się na stworzeniu warstw obiektów w celu transparentnego i dynamicznego uzupełniania obiektów o kolejne zadania. Dekorator dostarcza obiekt, o takim samym interfejsie co obiekt dekorowany. 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      25 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#kotlin-ref">kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Decorator-Pattern-ref">Decorator Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#extension-methods-ref">extension methods</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Wrapper-ref">Wrapper</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    26th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-adapter-pattern">Adapter w Kotlinie</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
     Adapter lub Wrapper pozwala `przetłumaczyć` jeden interfejs na inny, oczekiwany przez klienta. Jest to szczególnie przydatne, gdy adaptowany obiekt pochodzi z niezależnej biblioteki i nie chcemy uzależniać naszego systemu od jego interfejsu, tworząc tzw. `anticorruption layer`. Zmiany interfejsu obiektu wpłyną tylko na `Adapter` a nie na resztę kodu. 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      19 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Adapter-Pattern-ref">Adapter Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#structural-design-pattern-ref">structural design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    21st,
    
    2021
  </span>

  <h2>
    <a href="/pl/intellij-latex-editor">IntelliJ IDEA jako edytor LaTeX</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plToday I learned</a></p>-->

  <div>
    
    
     IntelliJ IDEA całkiem sprawnie radzi sobie z obsługą LaTeX. Śmiem twierdzić, że jest to nawet lepsze doświadczenie niż TexStudio czy Texmaker, które są dedykowane do tego typu projektów. Jednak siła IntelliJ nie polega na możliwościach `out of the box` ale na plugin-ach i ręcznej konfiguracji procesu budowania. 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      8 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#IDE-ref">IDE</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#plugins-ref">plugins</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#IntelliJ-ref">IntelliJ</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#LaTeX-ref">LaTeX</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    5th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-facade-pattern">Fasada w Kotlinie</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
     Fasada pozwala a ukrycie szczegółów modułu przed klientami. Zapewnia przestrzeganie `Prawa Demeter`, a użycie ogólnego interfejsu i różnych implementacji znacząco ułatwia testowanie. Dobrze łączy się z innymi wzorcami takimi jak `Strategia`, `Metoda Szablonowa` czy konstrukcyjnymi pozwalającymi na konfigurację obiektu udostępnianego klientom. Fasada dobrze nadaje się na punkt wejścia dla bibliotek, dając klientom dostęp do wysokopoziomowych funkcjonalności i chowając całą wewnętrzną logikę i klasy. 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      17 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Facade-Pattern-ref">Facade Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#structural-design-pattern-ref">structural design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    5th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-strategy-pattern">Wzorzec Strategia w Kotlinie</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
     Strategia tworzy rodzinę algorytmów, zamykając różniącą się logikę w osobnych klasach, jednocześnie ukrywając ją przed klientami za wspólnym interfejsem. Umożliwia wymienne stosowanie implementacji. Użycie strategii znacząco upraszcza kod klientów, pozwala uniknąć duplikacji kodu i instrukcji warunkowych. Znacząco ułatwia testowanie — oddzielając testowanie klienta od algorytmów strategii. 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      19 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Strategy-Pattern-ref">Strategy Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#behavioral-design-pattern-ref">behavioral design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    May
    13th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-template-method">Metoda szablonowa w Kotlinie</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
    Metoda szablonowa to bardzo prosty wzorzec, pozwalający oddzielić to, co stałe od tego, co zmienne w rodzinie klas.  Polega na utworzeniu abstrakcyjnej klasy nadrzędnej, zawierającej kolejne kroki jakiegoś algorytmu i pozwoleniu klasom dziedziczącym z niej nadpisywać poszczególne kroki, ale nie sam algorytm, który je wykorzystuje.
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      17 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Template-Method-ref">Template Method</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#behavioral-design-pattern-ref">behavioral design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    March
    7th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-abstract-factory">Kotlin Abstract Factory</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
    Fabryka fabryk, czyli 'Abstract Factory' usprawnia tworzenie obiektów będących częścią jakiejś 'rodziny'. Jest to w zasadzie warstwa opakowująca konkretne fabryki i dostarczająca klientom instancję fabryki tworzącą obiekty z danego wariantu.
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      32 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Abstract-Factory-ref">Abstract Factory</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#construction-design-pattern-ref">construction design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    February
    24th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-factory-method">Kotlin Factory Method</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
     Po `Static Factory Method` nadeszła pora na klasyczne `Factory`. Fabryka jest bardzo użytecznym i często stosowanym wzorcem konstrukcyjnym. Kotlin daje nam ciekawe możliwości dzięki klasom `sealed` oraz `internal`, których odpowiedników brakuje w Javie. 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      48 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Factory-Method-ref">Factory Method</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#construction-design-pattern-ref">construction design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    January
    20th,
    
    2021
  </span>

  <h2>
    <a href="/pl/kotlin-static-factory-methods">Kotlin Static Factory Methods</a> 
  </h2>

<!--  <p class="post_category">in <a href="/pl/categories.html#pl-ref">plDesign Patterns</a></p>-->

  <div>
    
    
     Znane z Javy `Statyczne Metody Wytwórcze` w Kotlinie jak najbardziej mają swoje zastosowanie, pomimo trochę innego zachowania i braku słówka `static`. Postaram się przybliżyć czym jest `companion object` i jak go można używać. PS: Ten post miał byc o wzorcu Factory Method z tylko krótką wzmianą o statycznych metodach fabrycznych, ale ten temat okazał się ciekawszy, niż sądziłem :) 
    
    
  </div>

<!--  <p class="read_time">(czas czytania:-->
<!--    -->
<!--    -->
<!--      15 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/pl/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#Static-Factory-Methods-ref">Static Factory Methods</a>
      </span>
    
      <span class="post_tags">
        <a href="/pl/tags.html#construction-design-pattern-ref">construction design pattern</a>
      </span>
    
  </p>

</article>

<hr/>

<ul class="pager">

  
  <li class="previous">
    
    <a href="/pl/">&larr; Newer</a>
    
  </li>
  

  <li>
    <span class="page_number">Page: 2 of 4</span>
  </li>

  
  <li class="next">
    <a href="/pl/page3">Older &rarr;</a>
  </li>
  

</ul>



  </body>
</html>



<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl =
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'G-313840737']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

