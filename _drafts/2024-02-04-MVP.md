---
layout: post
title: "Android Presentation Patterns: MVP"
date: "2024-01-29 16:04"
description: "

"
permalink: "2024-01-29-MVP"
comments: true
toc: true
tags:
  - Android
categories:
  - rss
image: /assets/posts/adapter.jpg

---

## But MVC does the job!

When you look into MVC pattern [like described here]() its clear, that direct relationship between `View`
and `Controller` is causing problems. Tight coupling results in difficult testing, changes in one class forcing to
update other, and it doesn't scale nicely. In complex views, there can be multiple conditions for setting values in
UI elements depending on current state of UI and responses from `Model`. And having complex logic when it's hard to
test it... **generates anarchy**.

This problem was clear for developers, and some started proposing better ways to implement MVC,
like [here](https://medium.com/upday-devs/android-architecture-patterns-part-1-model-view-controller-3baecef5f2b6)
, where `Controller` is a separate class from `Fragment` or `Activity`. Since its separate object from Android Framework
instances, we can use some interfaces to mock stuff around and be able to test the behavior.

## The Presenter is born

The evolution of MVP, as it is known in the context of Android development, can be traced back to Google's Web Toolkit (
GWT). In the mid-2000s, GWT adopted MVP as a response to the challenges faced in building modular and testable web
applications.

Let's have an interface for the `View` and `The-New-Controller-Type` but let's call it `Presenter` since it's
responsible for presenting model data to the `View`.
Simple diagram may look like this:

{% plantuml %}
@startuml

class Model {
}

interface View {
}

interface Presenter {
}

Model -- Presenter: notifies
View -- Presenter: interacts
Presenter -- Model: manipulates
Presenter -- View: updates

@enduml
{% endplantuml %}

Please note, that `View` and `Presenter` are interfaces, and while they still keep reference to each other, it's only by
the interface, not concrete implementation.
The interfaces are providing only methods relevant for particular UI interactions.

### Let there be Contract!

OK so now there is a set of interfaces, implemented by a concrete `View` and `Presenter`, to serve for particular UI
screen. It would be nice to keep them close, so its clear which `View` talks to which `Presenter`, there is always 1 to
1 relation.

{% plantuml %}
@startuml

interface ItemListContract {
}

interface Presenter {
+addItem(): void
+removeItem(): void
}

interface View {
+displayError(): void
+hideError(): void
+displayItems(): void
+showLoading(): void
+hideLoading(): void
}

View --* ItemListContract
Presenter --* ItemListContract

class ConcreteItemListFragment {
}

class ConcreteItemListPresenter {
}

ConcreteItemListFragment --|> View
ConcreteItemListPresenter --|> Presenter

@enduml
{% endplantuml %}

It looks nicer in Kotlin code:

```kotlin
interface ItemListContract {
    interface View {
        fun displayError(errorMessage: String)
        fun hideError()
        fun displayItems(items: List<Int>)
        fun showLoading()
        fun hideLoading()
    }

    interface Presenter {
        fun addItem()
        fun removeItem()
    }
}
```

The Activity being the `View` will look like this:

```kotlin
class MainActivity : AppCompatActivity(), ItemListContract.View {
    // creating instance of the presenter, can be also injected by DI
    private val presenter: ItemListContract.Presenter = MainViewPresenter()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // giving Presenter instance of the View
        // this should happen when the View is actually ready to perform its tasks
        // because Presenter may want to display something right after getting reference to the View
        presenter.attachView(this)
        ...
```

The `Presenter`

```kotlin
class MainViewPresenter : ItemListContract.Presenter {
    private lateinit var view: ItemListContract.View

    fun attachView(view: ItemListContract.View) {
        this.view = view
    }
}
```

No magic here, simple passing reference to `this` from `View` to `Presenter`, and from now on the `Presenter` should be
safe to call `View` methods. This is why it should happen in Activity or Fragment `onCreate` and not in the `Presenter`
constructor. Otherwise, you would have to call some extra `onViewReady()` on the `Presenter` when you have your view
prepared, with all elements assigned to fields with `findViewById()` etc.

The `View` and the `Presenter` know only each other `Contract`, so it should be nice to write `Presenter` tests, with
mocking of the `View` and verifying which methods were called and passed arguments.

## The boilerplate

You probably already identified the ugly part now. Each presenter has method `attachView` or similar, but it's not
really part of any common interface for `Presenter`. It would be really great to have some sort of framework, taking
care of all the boilerplate methods for `View` and `Presenter`, so our `Contract` can focus only on relevant methods for
particular UI scenario.

The `View` and `Presenter` couple should also be detached to avoid memory leaks, when the view is destroyed.

All `Presenter` work is done on the UI thread. Would be great to perform tasks on other threads, and cancel them when
the View is destroyed since the result it's not relevant anymore.

This can be achieved with introducing an abstract `BasePresenter`, that is also a `CoroutineScope`. The diagram starts
to be really complex, for a simple presentation layer architecture:

{% plantuml %}
@startuml

interface Presenter<VIEW: View> {
+attachView(view: VIEW): void
+detachView(): void
}

interface View {
}

abstract class BasePresenter<VIEW: View> {
-view: VIEW
-job: Job
+onViewAttached(): void
+onViewDetached(): void
}
interface CoroutineScope
BasePresenter <|-- Presenter
BasePresenter <|-- CoroutineScope

interface ItemListContract {
}

interface ItemListView {
+displayError(): void
+hideError(): void
+showLoading(): void
+hideLoading(): void
}

interface ItemListPresenter {
+addItem(): void
+removeItem(): void
}

class ConcreteItemListFragment{
}

ItemListContract --|> ItemListView
ItemListContract --|> ItemListPresenter
ItemListPresenter --|> Presenter
ItemListView --|> View
ConcreteItemListPresenter --|> ItemListPresenter
ConcreteItemListPresenter --|> BasePresenter
ConcreteItemListFragment --|> ItemListView

@enduml
{% endplantuml %}

### BasePresenter

It looks more complex than it is. Each ConcretePresenter implements Contract.Presenter for its domain capabilities and
BasePresenter for common methods like `attachView()` or `detachView()`.
The BasePresenter provides CoroutineContext, so running methods on Model won't happen on UI thread, and jobs will be
canceled when view is detached.

Kotlin implementation:

```kotlin
abstract class BasePresenter<VIEW : View> : Presenter<VIEW>, CoroutineScope {
    internal lateinit var view: VIEW

    private var job: Job = SupervisorJob()

    override val coroutineContext: CoroutineContext
        get() = Dispatchers.IO + job

    override fun attachView(view: VIEW) {
        this.view = view
        onViewAttached()
    }

    override fun detachView() {
        job.cancel()
        onViewDetached()
    }

    abstract fun onViewAttached()
    abstract fun onViewDetached()
}
```

Because the jobs are performed outside the UI thread, and only UI thread can modify UI elements, the `View` methods
implementation has to use something like this:

```kotlin
override fun displayLoading() {
    runOnUiThread {
        progressBar.visibility = View.VISIBLE
    }
}
```

### View and Presenter interfaces

There are also new interfaces for generic `View` and `Presenter`

```kotlin
interface Presenter<VIEW : View> {
    fun attachView(view: VIEW)
    fun detachView()
}

interface View

// Contract
interface Contract {
    interface ConcreteView : View

    interface ConcretePresenter : Presenter<ConcreteView>
}
```

Using generics guarantees everything is connected in the right way. The `MainViewPresenter` now have to inherit from
both
the contract presenter interface, and the `BasePresenter`. It's not ideal, but allows to keep behavior relevant to the
contract
in separate place from behavior relevant for the presenter base functionality.

```kotlin
class MainViewPresenter : Contract.ConcretePresenter, BasePresenter<Contract.ConcreteView>()
```

The `ConcretePresenter` and `BasePresenter<Contract.ConcreteView>` are having the same `ConcreteView` view, so it all
works nicely. This way, the `View` doesn't have to know about the `BasePresenter` interface to use `attachView()`
and `detachView()`. Those methods are part of `Presenter` interface, that `ConcretePresenter` inherits. `BasePresenter`
also inherits this interface, and it provides actual implementation for assigning `View` reference and handling job
cancellation. Still, it gives `ConcretePresenter` implementation a way to perform some actions when the view is attached
with the

```kotlin
abstract fun onViewAttached()
abstract fun onViewDetached()
```

So with a relatively small cost of remembering to always inherit from `BasePresenter`, we get nice separation of
behaviors, and our `Contract` can focus on UI handling, rather than technical details of threading etc.

There were no changes for the `View` implementation, the `ConcretePresenter` interface has all the relevant methods.

### Presenter implementation

Let's look into `MainViewPresenter` code:

```kotlin
override fun removeItem(item: Int) {
    launch {
        view.displayLoading()
        Model.removeItem(item)
            .onFailure { error ->
                view.hideLoading()
                displayErrorMessage(error)
            }
            .onSuccess {
                view.hideLoading()
            }
    }
}
```

Every method from `ConcretePresenter` looks similar. It's wrapped in `launch` block, because the `BasePresenter` is a
CoroutineScope, and it's setting the context in its implementation:

```kotlin
    private var job: Job = SupervisorJob()
override val coroutineContext: CoroutineContext
    get() = Dispatchers.IO + job
```

The Job is canceled when the view is detached. In my implementation, the `Model` is returning a Kotlin `Result`, so I
can handle errors nicely with the `onFailure()` extension method.
Method `removeItem()` is telling `View` to display some loading. Some, because its up to the `View` implementation on
how to do this. The `Presenter` has no idea is it a `LinearProgressIndicator` or `CircularProgressIndicator`, or maybe a
Dialog with text "please wait". Thanks to this, whole UI can even get redesign with very little impact on `Presenter`.
The `Controller` typically had to know much more about `View` details.
Same goes with `displayErrorMessage()`, we can define what data is passed to `View` in the `Contract`, and we don't
have to rely on any Android Framework limitations here.

After item is successfully removed `Presenter` is just hiding the loading. What about refreshing data? Well it happens
automatically:

```kotlin
override fun onViewAttached() {
    launch {
        Model.itemsFlow.collect { items ->
            view.displayItems(items)
        }
    }
}
```

`Presenter` is observing items flow from Model, and updates `View` with each new change. Old-fashioned way of achieving
this would be to get new data from Model after removing item, and passing it to the `View`.

## Common problems of MVP

While Model-View-Presenter (MVP) offers several advantages over MVC, it's important to be aware of some common issues
associated with this architectural pattern.

1. **Boilerplate Code:**
    - Each component (Model, View, and Presenter) requires its own set of interfaces and implementations, leading to
      verbose code.
2. **Complexity for Simple UIs:**
    - For simple user interfaces, the introduction of MVP may seem like an overhead. In cases where the UI logic is
      straightforward, the additional layers introduced by MVP might be considered unnecessary.
3. **Learning Curve:**
    - Developers who are new to MVP may find it challenging to understand the separation of concerns and the proper
      communication flow between the components. This can result in a steeper learning curve compared to simpler
      patterns.
4. **Presenter Responsibilities:**
    - Determining what should go into the Presenter and what should stay in the View or Model is not always
      straightforward. Deciding on the proper distribution of responsibilities can lead to ambiguity and inconsistencies
      across implementations.
5. **Tight Coupling:**
    - While MVP aims to reduce coupling compared to MVC, there's still a potential for tight coupling between the View
      and Presenter, especially if not implemented carefully. This can make it harder to replace or modify one component
      without affecting the other.
6. **Difficulty in Lifecycle Management:**
    - Managing the lifecycle of components in MVP, especially in Android where the activity and fragment lifecycles are
      critical, can be challenging. Improper management may result in memory leaks or unexpected behavior.
7. **No standardization:**
    - Unlike some other patterns, there is no strict standardization for MVP, leading to variations in implementations.
      This lack of a standard can make it challenging for developers to move between projects seamlessly.

It's important to note that the issues mentioned above are not inherent flaws in MVP but rather considerations and
trade-offs. The appropriateness of MVP depends on the specific needs of the project and the **preferences and experience
of the development team**. Additionally, some of these issues can be mitigated with proper design practices and
libraries
that support MVP, such as dependency injection frameworks.

## Conclusion

MVP is a step in a right direction from MVC. It's also not that hard to actually refactor from MVC to MVP. Nowadays, we
can benefit from using coroutines, flows or `Result` class, to avoid callback hell and easy threading. The pattern
provides clear(er) separation of concerns. It's finally easy to test code between `Model` and the `View`.

The MVP pattern version I showed in this post requires a bit of boilerplate, even for low complexity UI. But the same
time, a lot of technical issues are hidden and developers may focus solly on the `Contract`.

Even now when I look on extended MVP diagram it looks a bit scary. There is a lot of interfaces and it may look lie an
overkill. If only there was a way to achieve similar separation of concerns, testability and ease of use... oh wait,
there is MVVM :)