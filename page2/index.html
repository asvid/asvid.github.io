<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="refresh" content="0;url=https://swiderski.tech/" />
    <title>Redirecting...</title>
    <script>
      var currentUrl = window.location.href
      var path = currentUrl.split('asvid.github.io')[1]
      window.location.href = 'https://swiderski.tech' + path
    </script>
  </head>
  <body>
    <div class="page-header">
  <h1>Adam's Coding Corner </h1>
</div>



<article class="home">

  <span class="post-date">
    
    July
    17th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin_mediator_pattern">Mediator in Kotlin</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     The Mediator's job is to organize communication between close classes. The `Mediator` pattern cuts out dependencies between components. It takes over the interaction between them, becoming the main communication hub for a group of classes. There is a reverse of the controls because components are now just telling 'what happened' instead of telling others to 'do something'. It can be found e.g. in the form of `ViewModel` in Android, where it separates UI interactions from data model changes. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      22 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#kotlin-ref">kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Mediator-Pattern-ref">Mediator Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    July
    3rd,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-decorator-pattern">Decorator Pattern in Kotlin</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     The `Decorator` pattern is used where creating separate classes which are a combination of all possibilities would result in their explosion. This pattern focuses on creating object layers to transparently and dynamically complement objects with new tasks. The decorator provides an object with the same interface as the decorated object. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      27 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#kotlin-ref">kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Decorator-Pattern-ref">Decorator Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#extension-methods-ref">extension methods</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Wrapper-ref">Wrapper</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    26th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-adapter-pattern">Adapter Pattern in Kotlin</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     The Adapter or Wrapper Pattern allows you to `translate` one interface into another, expected by the client class. It is especially useful when the adapted object comes from 3rd party library, and you do not want to make your system depending on that interface, creating the so-called `anticorruption layer`. Adaptee interface changes will only affect the `Adapter` and not the rest of the code. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      21 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Adapter-Pattern-ref">Adapter Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#structural-design-pattern-ref">structural design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    21st,
    
    2021
  </span>

  <h2>
    <a href="/intellij-latex-editor">IntelliJ IDEA as a LaTeX editor</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Today-I-learned-ref">Today I learnedrss</a></p>-->

  <div>
    
    
     IntelliJ IDEA is pretty good at handling LaTeX. I dare say that it is an even better experience than TexStudio or Texmaker, which are dedicated to this type of project. However, the strength of IntelliJ is not in its out-of-the-box capabilities, but plugins and manual configuration of the build process. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      9 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#IDE-ref">IDE</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#plugins-ref">plugins</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#IntelliJ-ref">IntelliJ</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#LaTeX-ref">LaTeX</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    13th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-facade-pattern">Facade Pattern in Kotlin</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     The facade allows you to hide the details of the module from clients. It ensures compliance with `Law Demeter`. Using the generic interface and various implementations greatly simplifies testing. It blends well with other patterns like `Strategy`,` Template Method`, or construction patterns, allowing configuration of the object available for the clients. The facade is a good entry point for libraries, giving customers access to high-level functionality and hiding all internal logic and classes. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      18 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Facade-Pattern-ref">Facade Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#structural-design-pattern-ref">structural design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    June
    5th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-strategy-pattern">Strategy Pattern in Kotlin</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     The `Strategy` pattern creates a family of algorithms, enclosing the differing logic in separate classes while hiding it from clients behind the interface. It enables the interchangeable use of implementations. The use of the strategy simplifies the customer code, avoids code duplication and conditional statements. Significantly simplifies testing - by separating client testing from strategy algorithms. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      22 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Strategy-Pattern-ref">Strategy Pattern</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#behavioral-design-pattern-ref">behavioral design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    May
    18th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-template-method">Kotlin Template Method</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
    The template method is a very simple design pattern, that separates shared class parts from changing ones. The core idea is to have an abstract parent class containing the algorithm steps and allowing inheriting classes to overwrite individual steps, but not the algorithm that uses those steps itself.
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      18 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Template-Method-ref">Template Method</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#behavioral-design-pattern-ref">behavioral design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    March
    8th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-abstract-factory">Kotlin Abstract Factory</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     The factory of factories, 'Abstract Factory' makes creating objects that are part of some 'family' easy. It is another layer over concrete factories delivering client the factory instance for creating objects of a certain variant. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      34 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Abstract-Factory-ref">Abstract Factory</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#construction-design-pattern-ref">construction design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    February
    26th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-factory-method">Kotlin Factory Method</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     After the `Static Factory Method` it's time for classic `Factory`. Factory is very useful and often used construction design pattern. Kotlin has interesting advantage thanks to `sealed` and `internal` classes, that are missing in Java. 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      49 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Factory-Method-ref">Factory Method</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#construction-design-pattern-ref">construction design pattern</a>
      </span>
    
  </p>

</article>


<article class="home">

  <span class="post-date">
    
    February
    15th,
    
    2021
  </span>

  <h2>
    <a href="/kotlin-static-factory-methods">Kotlin Static Factory Methods</a> 
  </h2>

<!--  <p class="post_category">in <a href="/categories.html#Design-Patterns-ref">Design Patternsrss</a></p>-->

  <div>
    
    
     `Static Factory Methods` known from Java have their place also in Kotlin, although they look and behave a bit different because there is no `static` word in Kotlin. Here I'll try to show how to use `companion object` for `Static Factory Methods` and more. PS: This whole post was supposed to be about `Factory Method` with just a short mention about static factory methods, but the topic becomes more interesting than I thought :) 
    
    
  </div>

<!--  <p class="read_time">(read time:-->
<!--    -->
<!--    -->
<!--      17 mins)-->
<!--    -->
<!--    </p>-->

  <p>
    
      <span class="post_tags">
        <a href="/tags.html#design-patterns-ref">design patterns</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Kotlin-ref">Kotlin</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#Static-Factory-Methods-ref">Static Factory Methods</a>
      </span>
    
      <span class="post_tags">
        <a href="/tags.html#construction-design-pattern-ref">construction design pattern</a>
      </span>
    
  </p>

</article>

<hr/>

<ul class="pager">

  
  <li class="previous">
    
    <a href="/">&larr; Newer</a>
    
  </li>
  

  <li>
    <span class="page_number">Page: 2 of 4</span>
  </li>

  
  <li class="next">
    <a href="/page3">Older &rarr;</a>
  </li>
  

</ul>



  </body>
</html>



<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl =
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'G-313840737']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

